<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Bastian Schiffthaler and Carolina Bernhardsson" />

<meta name="date" content="2017-03-07" />

<title>BatchMap algorithm for the creation of high density linkage maps in outcrossing species</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">BatchMap algorithm for the creation of high density linkage maps in outcrossing species</h1>
<h4 class="author"><em>Bastian Schiffthaler and Carolina Bernhardsson</em></h4>
<h4 class="date"><em>2017-03-07</em></h4>



<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>In general, the reader is encouraged to go through the excellent documentation of the original OneMap package before going through this vignette. An up-to-date version can be found <a href="https://github.com/augusto-garcia/onemap/raw/master/inst/doc/Tutorial_Onemap_reduced_version.pdf">here</a>. The majority of the pipeline still works the same or very similar to the implementations in OneMap (also internally). For those already familiar with the original or those looking for a quick summary, feel free to go on.</p>
<p>NOTE: BatchMap has been written specifically for use in outcrossing species. All OneMap functionality pertaining to back-crosses, f2, ril etc. has been removed for the sake of easier code maintenance. If your use case is not an outcrossing F1 population, turn back now.</p>
</div>
<div id="reading-data-into-r" class="section level2">
<h2>Reading data into R</h2>
<p>BatchMap keeps with the paradigm and format of the original OneMap data format, but includes a faster function for reading the input file <code>read.outcross2</code>. Further, BatchMap ignores all lines following the marker definitions (e.g.Â phenotypes) as all exploration beyond the construction of the linkage map is not intended to be handled by this package.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">suppressPackageStartupMessages</span>(<span class="kw">library</span>(BatchMap))

input_file &lt;-<span class="st"> </span><span class="kw">system.file</span>(<span class="st">&quot;example/sim2k.txt&quot;</span>,<span class="dt">package =</span> <span class="st">&quot;BatchMap&quot;</span>)
outcross &lt;-<span class="st"> </span><span class="kw">read.outcross2</span>(input_file)
outcross</code></pre></div>
</div>
<div id="detecting-bins-and-resolving-them" class="section level2">
<h2>Detecting bins and resolving them</h2>
<p>High density marker data often has bins of identical markers, which cause problems when estimating recombination fractions, and can in the case of the BatchMap approach make the resulting map worse. OneMap provides functions to detect and resolve such bins. Note the <code>exact</code> option to <code>find.bins()</code>, which controls wether missing information should be considered when binning data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">bins &lt;-<span class="st"> </span><span class="kw">find.bins</span>(outcross, <span class="dt">exact =</span> <span class="ot">FALSE</span>)
outcross_clean &lt;-<span class="st"> </span><span class="kw">create.data.bins</span>(outcross, bins)
outcross_clean</code></pre></div>
<p>Note the difference in the number of markers.</p>
</div>
<div id="calculating-the-twopoint-table" class="section level2">
<h2>Calculating the twopoint table</h2>
<p>The function <code>rf.2pts()</code> calculates the twopoint table for markers. Note that with very high density datasets, a lot of RAM can be required to hold the twopoint table. As a general rule, this datastructure will require <span class="math inline">\(M * M * 32\)</span> bytes, where <span class="math inline">\(M\)</span> is the number of markers. In our case, with a small dataset of 2,085 markers, weâll need about 133Mb. A large dataset of 20,000 markers will need <strong>&gt;48Gb</strong>. This would be typically run on a server machine (e.g.Â see some cloud server providers).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">twopt_table &lt;-<span class="st"> </span><span class="kw">rf.2pts</span>(outcross_clean)
<span class="co"># Check the size</span>
<span class="kw">format</span>(<span class="kw">object.size</span>(twopt_table),<span class="dt">units =</span> <span class="st">&quot;Mb&quot;</span>)</code></pre></div>
</div>
<div id="grouping" class="section level2">
<h2>Grouping</h2>
<p>In order to separate the data into linkage groups, we use the <code>group()</code> function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">linkage_groups &lt;-<span class="st"> </span><span class="kw">group</span>(<span class="kw">make.seq</span>(<span class="dt">input.obj =</span> twopt_table, <span class="st">&quot;all&quot;</span>),
                        <span class="dt">LOD =</span> <span class="dv">12</span>)</code></pre></div>
</div>
<div id="splittint-the-data-into-pseudo-testcrosses" class="section level2">
<h2>Splittint the data into pseudo testcrosses</h2>
<p>In order to calculate a map for each parent and then join them afterwards, we provide a function <code>pseudo.testcross.split()</code>, that creates a list of testcrosses. Each list element corresponds to a linkage group and a sequence for markers of type âD1.10â and one for markers of type âD2.15â. Both include all markers of other types.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">testcrosses &lt;-<span class="st"> </span><span class="kw">pseudo.testcross.split</span>(linkage_groups)
testcrosses$LG1.d1<span class="fl">.10</span></code></pre></div>
</div>
<div id="ordering-sequences-in-parallel" class="section level2">
<h2>Ordering sequences in parallel</h2>
<p>Before the map is calculated using the EM model, the sequences need to be ordered by a heuristic. The RECORD algorithm usually performs very well and has desireable characteristics, which make it trivial to parallelize. We use the function <code>record.parallel()</code>, which takes a <code>sequence</code> as input and we replicate RECORD 10 times (see the <code>times</code> argument). We then pick the best of those replicates as our final order. Note that it is rare for <code>times &gt; 10</code> to yield any significant improvement. Finally, the <code>cores</code> argument defines how many of those RECORD replicates we can process in parallel. Set this to your computers number of CPUs (or maximally the number of the <code>times</code> argument).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ordered_sequences &lt;-<span class="st"> </span><span class="kw">lapply</span>(testcrosses, record.parallel, <span class="dt">times =</span> <span class="dv">10</span>, <span class="dt">cores =</span> <span class="dv">1</span>)</code></pre></div>
</div>
<div id="creating-the-batchmaps" class="section level2">
<h2>Creating the BatchMaps</h2>
<p>With the sequences neatly ordered, we can now go ahead with creating BatchMaps. For this, we define an overall batch size as well as an overlap size and let the function <code>pick.batch.sizes()</code> decide on the final size in order to split batches evenly. The <code>around</code> argument to the function defines how much smaller or larger the batch size is allowed to be in order to create evenly sized batches. We will work with linkage group 1 from here on to save time:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">LG1_d1<span class="fl">.10</span> &lt;-<span class="st"> </span>ordered_sequences$LG1.d1<span class="fl">.10</span>
LG1_d2<span class="fl">.15</span> &lt;-<span class="st"> </span>ordered_sequences$LG1.d2<span class="fl">.15</span>
batch_size_LG1_d1<span class="fl">.10</span> &lt;-<span class="st"> </span><span class="kw">pick.batch.sizes</span>(LG1_d1<span class="fl">.10</span>, 
                                         <span class="dt">size =</span> <span class="dv">50</span>, 
                                         <span class="dt">overlap =</span> <span class="dv">30</span>, 
                                         <span class="dt">around =</span> <span class="dv">10</span>)
batch_size_LG1_d2<span class="fl">.15</span> &lt;-<span class="st"> </span><span class="kw">pick.batch.sizes</span>(LG1_d2<span class="fl">.15</span>, 
                                         <span class="dt">size =</span> <span class="dv">50</span>, 
                                         <span class="dt">overlap =</span> <span class="dv">30</span>, 
                                         <span class="dt">around =</span> <span class="dv">10</span>)
<span class="kw">c</span>(batch_size_LG1_d1<span class="fl">.10</span>, batch_size_LG1_d2<span class="fl">.15</span>)</code></pre></div>
<p>Now all thatâs left to do is to call <code>map.overlapping.batches()</code>. This function has a great deal of options. For now, take away that <code>phase.cores</code> controls the number of parallel threads used to estimate the correct linkage phase between a pair of markers. As there are no more than four possible phases, this should never exceed four. The <code>size</code> and <code>overlap</code> arguments should match the output of <code>pick.batch.sizes()</code> with the given overlap. The <code>verbosity</code> option can be set to output different types of progress reports.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">map_LG1_d1<span class="fl">.10</span> &lt;-<span class="st"> </span><span class="kw">map.overlapping.batches</span>(<span class="dt">input.seq =</span> LG1_d1<span class="fl">.10</span>,
                                         <span class="dt">size =</span> batch_size_LG1_d1<span class="fl">.10</span>,
                                         <span class="dt">phase.cores =</span> <span class="dv">1</span>,
                                         <span class="dt">overlap =</span> <span class="dv">30</span>)</code></pre></div>
<p>The result of <code>map.overlapping.batches()</code> has a data member <code>$Map</code>, which corresponds to the final map:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">map_LG1_d1<span class="fl">.10</span>$Map</code></pre></div>
<p>The maps were simulated to be 100cM, which we come very close to. However, the markers in the simulated map are also ordered by their name, so M1 -&gt; M2 -&gt; M3 et cetera. We can spot some errors in the results, which can be improved in the next section.</p>
</div>
<div id="batchmap-with-ripple-to-improve-order" class="section level2">
<h2>BatchMap with ripple to improve order</h2>
<p>As we saw at the end of the previous section, the markers still have some order error. While we can probably never recover the true map, we can expend resources (CPU time) to improve the current order. To do this, we can supply an ordering function to <code>map.overlapping.batches()</code> using the <code>fun.ord</code> argument. Currently there exists an umbrella function called <code>ripple.ord()</code> that should be supplied to this argument. This function will go through sliding windows within each batch and test alternative orders according to a given rule set. If an order improves the map likelihood, it is kept. The default and recommended ruleset is called âoneâ, and will test each <strong>pairwise</strong> marker swap within a window. Further, a number of alternative orders can be considered in parallel. This is controlled by the <code>ripple.cores</code> argument. Note that the total number of threads used, will be <code>ripple.cores</code> * <code>phase.cores</code>.</p>
<p>How many cores will I need?</p>
<p>Depending on the rule set and window size that <code>ripple.ord()</code> uses, the number of comparisons can be calculated. Let the <span class="math inline">\(w\)</span> be the window size:</p>
<ul>
<li>âoneâ: <span class="math inline">\(\frac{w * (w + 1)}{2}\)</span></li>
<li>âallâ: <span class="math inline">\(\frac{w!}{2}\)</span></li>
</ul>
<p>The rule set ârandomâ can be supplied with the number of desired alternative orders. Letâs consider a window size of 4 for our dataset. We will need to test <span class="math inline">\(\frac{4 * 5}{2} = 10\)</span> alternative order per window. On a machine with 16 threads available, a good combination would be <code>phase.cores=3</code> and <code>ripple.cores=5</code>, as often no more than two phases are plausible and even considered in the model. I am writing this vignette on a laptop with four cores available, which I will all use for <code>ripple.cores</code>, setting <code>phase.cores</code> to one. The rule set used by <code>ripple.ord()</code> is controlled by the <code>method</code> argument, the window size by the <code>ws</code> argument. Even with only about 100 markers, this function can take some time, it is advised you donât run it here.:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">rip_LG1_d1<span class="fl">.10</span> &lt;-<span class="st"> </span><span class="kw">map.overlapping.batches</span>(<span class="dt">input.seq =</span> LG1_d1<span class="fl">.10</span>,
                                         <span class="dt">size =</span> batch_size_LG1_d1<span class="fl">.10</span>,
                                         <span class="dt">phase.cores =</span> <span class="dv">1</span>,
                                         <span class="dt">overlap =</span> <span class="dv">30</span>,
                                         <span class="dt">fun.order =</span> ripple.ord,
                                         <span class="dt">ripple.cores =</span> <span class="dv">4</span>,
                                         <span class="dt">method =</span> <span class="st">&quot;one&quot;</span>,
                                         <span class="dt">min.tries =</span> <span class="dv">1</span>,
                                         <span class="dt">ws =</span> <span class="dv">4</span>)</code></pre></div>
<p>We can evaluate the number of mistakes in the order, because the true order is known in the simulated dataset:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">err_rate &lt;-<span class="st"> </span>function(seq)
{
  <span class="co"># Get the marker position</span>
  s_num &lt;-<span class="st"> </span>seq$seq.num
  <span class="co"># If the sequence is reverse, turn it around</span>
  if(<span class="kw">cor</span>(s_num, <span class="dv">1</span>:<span class="kw">length</span>(s_num)) &lt;<span class="st"> </span><span class="dv">0</span>)
    s_num &lt;-<span class="st"> </span><span class="kw">rev</span>(s_num)
  <span class="co"># Get the number of misorders and divide by the total length</span>
  <span class="kw">sum</span>(<span class="kw">order</span>(s_num) -<span class="st"> </span><span class="dv">1</span>:<span class="kw">length</span>(s_num) !=<span class="st"> </span><span class="dv">0</span>) /<span class="st"> </span><span class="kw">length</span>(s_num)
}

<span class="kw">c</span>(<span class="st">&quot;BatchMap&quot;</span> =<span class="st"> </span><span class="kw">err_rate</span>(map_LG1_d1<span class="fl">.10</span>$Map),
  <span class="st">&quot;RippleBatchMap&quot;</span> =<span class="st"> </span><span class="kw">err_rate</span>(rip_LG1_d1<span class="fl">.10</span>$Map))</code></pre></div>
<pre><code>## [1] 0.3723404 0.2234043</code></pre>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
